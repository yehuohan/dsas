
# OS(x86) learning

视频教程：
 - [操作系统](http://www.xuetangx.com/courses/course-v1:TsinghuaX+30240243X+sp/about)

参考资料：
 - [X86端口](http://bochs.sourceforge.net/techspec/PORTS.LST)
 - [分段机制与GDT,LDT](https://www.cnblogs.com/chenwb89/p/operating_system_003.html)

---
# OS启动

```text
X86 Memory Map（32位，最多4GB内存）

  |-----------| 0xFFFFFFFF (4GB)
  |           |
  |Free Space |
  |-----------|
  |           |
  |OS         |
  |-----------| 0x00100000 (1MB)
  |           |
  |BIOS       |
  |-----------| 0x000A0000 (640KB)
  |           |
  |Free Space |
  |-----------|
  |bootloader |
  |-----------| 0x00007C00
  |           |
  |Free Space |
  |-----------| 0x00000000

```

 - BIOS加载DISK的第一个扇区的bootloader至0x7C00，bootloader在DISK上找到OS并加载OS至MEM。
 - bootloader必须以0x55和0xAA结尾。

附：

现在新的电脑一般都采样UEFI的启动模式，电脑会在FAT分区上寻找指定的efi引导程序（如bootx64.efi），然后通过efi程序来加载内核和初始化系统。

---
# OS与外设、程序的交互

 - 系统调用：来于应用程序

POSIX API用于POSIX-based系统，包括UNIX、Linux等；而Win32 API用于Windows系统。

 - 异常：来于不良应用程序
 - 中断：来于外设

---
# OS内存管理

## 内存结构

内存大致包括3部分：

```text
|-------------------------|
|CPU寄存器，L1缓存，L2缓存| : CPU内部内存，速度快，但容量小
|-------------------------|
|主存                     |
|-------------------------|
|硬盘（虚拟内存）         |
|-------------------------|

```

## 内存地址空间管理

内存管理的基本要求：

 - 抽象：提供进程可访问的逻辑地址空间（可以对应到内存物理地址空间）
 - 保护：为进程提供独立的地址空间，保证程序间互不干扰
 - 共享：访问相同内存，提供进程间的交互
 - 虚拟化：利用硬盘提供更多的地址空间

内存管理的实现高度依赖于硬件，比如MMU（内存管理单元）用于负责处理CPU的内存访问请求。

## 连续内存分配

内存分配时会有内存碎片问题，包括外部碎片（进程序的内存无法得到利用）和内部碎片（分配给进程的内存无法得到利用）。

基本内存分配方法：

 - 第一匹配分配：遍历空间内存块，使用第一个满足需求的空闲内存块（易产生外碎片）
 - 最优匹配分配：遍历空间内存块，使用与需要求空间相差最小的空闲内存块（易产生微小外碎片）
 - 最差匹配分配：遍历空间内存块，使用与需要求空间相差最大的空闲内存块（易产生大的外碎片）

## 非连续内存分配

### 分段机制

软件：一个应用程序编译成代码段、数据段、栈段、堆段等部分
硬件：分段寻址

### 分页机制

 - 分页地址空间

物理内存划分成固定大小的帧，逻辑地址划分至相同大小的页；
使用 `页表，MMU/TLB` 转换逻辑地址到物理地址。

物理地址分页计算：

```text
地址总线：F+S 位
|----------------------------|
|帧位=F位  |  帧内偏移位=S位 |
|----------------------------|

物理地址addr(f, o) = 2^S * f + o
其中f : 帧号，共2^F帧，每帧2^S字节
    o : 帧内偏移地址，最大为2^S
```

逻辑地址（程序中）分页计算：

```text
逻辑地址宽度：P+S 位
|----------------------------|
|页位=P位  |  页内偏移位=S位 |
|----------------------------|

逻辑地址addr(p, o) = 2^S * p + o
其中p : 页号，总2^P页，第页2^S字节
    o : 页内偏移地址，最大为2^S
```

 - 分页寻址

用`页表`保存`逻辑地址`到`物理地址`之间的映射关系。映射通过数组来实现，具体来说，下标为页号p存储的是对应的帧号f，而物理地址偏移与逻辑地址偏移相等。

> 页映射到帧；
> 页是连续的虚拟内存；
> 帧是非连续的物理地址；
> 不是所有的页都有对应的帧。

### 页表

 - 页表访问速度问题

使用TLB(Translation Look-aside Buffer，具备快速访问性能)缓存近期访问页表项。

 - 页表存储空间问题

使用多级页表，减小不必要的页表项存储；但是页表级数变多时，映射访问就变得繁锁。如下是一个二级级表的示例：

```text
逻辑地址宽度：P1+P2+S 位
|----------------------------------------------|
|一级分页=P1位 |二级分页=P2位 | 页内偏移位=S位 |
|----------------------------------------------|

有两个页号，对应也有两个页表（数组）,通过index访问：
一级页表Table[2 ^ p1] = 二级页表的index
二级页表Table[index ] = 物理地址帧号f
```

建立反向页表，让页表与物理地址空间对应。可以这样理解，逻辑地址对应的物理地址存在，才将映射放入页表中，所以，这是一个大（逻辑）地址空间，到 小（物理）地址空间的映射，可以使用Hash表来建立这种映射关系，不过要注意Hash的碰撞问题。

```text
Hash(PID, p) = f
进行Hash计算时，可以加入程序PID等参数，缓解碰撞问题。
```

## 虚拟内存

理想的存储器：更大、更快、更便宜的非易失性存储器

### 覆盖技术

为了在较小的内存中运行较大的程序，将程序划分成若干功能相互独立的功能模块：

 - 必要部分：放于内存
 - 可选部分：平在放于外存，需要时才装入内存

不存在调用关系的模块不必同时装入内存，从而可以相互覆盖。
但是，为了确定覆盖关系，会增加编程的复杂度，而从外存装载数据到内存，会增加时间开销。

```
                                   -------------
       A(20K)             A    -> |常驻区(20K)  |
      /      \                    |-------------|
 B(50K)     C(30K)        B,C  -> |覆盖区0 (50K)|
   |        /   \                 |-------------|
 D(30K) E(20K)  F(40K)    D,E,F-> |覆盖区1 (40K)|
                                 -------------

另一种覆盖方法：
 A     -> 常驻区 (20K)
 B,E,F -> 覆盖区0 (50K)
 C,D   -> 覆盖区1 (30K)
```

### 交换技术

