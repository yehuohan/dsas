
# OS(x86) learning

视频教程：
 - [操作系统](http://www.xuetangx.com/courses/course-v1:TsinghuaX+30240243X+sp/about)

参考资料：
 - [X86端口](http://bochs.sourceforge.net/techspec/PORTS.LST)
 - [分段机制与GDT,LDT](https://www.cnblogs.com/chenwb89/p/operating_system_003.html)

---
# OS启动

```text
X86 Memory Map（32位，最多4GB内存）

  |-----------| 0xFFFFFFFF (4GB)
  |           |
  |Free Space |
  |-----------|
  |           |
  |OS         |
  |-----------| 0x00100000 (1MB)
  |           |
  |BIOS       |
  |-----------| 0x000A0000 (640KB)
  |           |
  |Free Space |
  |-----------|
  |bootloader |
  |-----------| 0x00007C00
  |           |
  |Free Space |
  |-----------| 0x00000000

```

 - BIOS加载DISK的第一个扇区的bootloader至0x7C00，bootloader在DISK上找到OS并加载OS至MEM。
 - bootloader必须以0x55和0xAA结尾。

附：

现在新的电脑一般都采样UEFI的启动模式，电脑会在FAT分区上寻找指定的efi引导程序（如bootx64.efi），然后通过efi程序来加载内核和初始化系统。

---
# OS与外设、程序的交互

 - 系统调用：来于应用程序

POSIX API用于POSIX-based系统，包括UNIX、Linux等；而Win32 API用于Windows系统。

 - 异常：来于不良应用程序
 - 中断：来于外设

---
# OS内存管理

## 内存结构

内存大致包括3部分：

```
 |-------------------------|
 |CPU寄存器，L1缓存，L2缓存| : CPU内部内存，速度快，但容量小
 |-------------------------|
 |主存                     |
 |-------------------------|
 |硬盘（虚拟内存）         |
 |-------------------------|
 ```

## 内存地址空间管理

内存管理的基本要求：

 - 抽象：提供进程可访问的逻辑地址空间（可以对应到内存物理地址空间）
 - 保护：为进程提供独立的地址空间，保证程序间互不干扰
 - 共享：访问相同内存，提供进程间的交互
 - 虚拟化：利用硬盘提供更多的地址空间

内存管理的实现高度依赖于硬件，比如MMU（内存管理单元）用于负责处理CPU的内存访问请求。

## 连续内存分配

内存分配时会有内存碎片问题，包括外部碎片（进程序的内存无法得到利用）和内部碎片（分配给进程的内存无法得到利用）。

基本内存分配方法：

 - 第一匹配分配：遍历空间内存块，使用第一个满足需求的空闲内存块（易产生外碎片）
 - 最优匹配分配：遍历空间内存块，使用与需要求空间相差最小的空闲内存块（易产生微小外碎片）
 - 最差匹配分配：遍历空间内存块，使用与需要求空间相差最大的空闲内存块（易产生大的外碎片）

## 非连续内存分配

### 分段机制

软件：一个应用程序编译成代码段、数据段、栈段、堆段等部分
硬件：分段寻址

### 分页机制

 - 分页地址空间

物理内存划分成固定大小的帧，逻辑地址划分至相同大小的页；
使用 `页表，MMU/TLB` 转换逻辑地址到物理地址。

物理地址分页计算：

```text
地址总线：F+S 位
|----------------------------|
|帧位=F位  |  帧内偏移位=S位 |
|----------------------------|

物理地址addr(f, o) = 2^S * f + o
其中f : 帧号，共2^F帧，每帧2^S字节
    o : 帧内偏移地址，最大为2^S
```

逻辑地址（程序中）分页计算：

```text
逻辑地址宽度：P+S 位
|----------------------------|
|页位=P位  |  页内偏移位=S位 |
|----------------------------|

逻辑地址addr(p, o) = 2^S * p + o
其中p : 页号，总2^P页，第页2^S字节
    o : 页内偏移地址，最大为2^S
```

 - 分页寻址

用`页表`保存`逻辑地址`到`物理地址`之间的映射关系。映射通过数组来实现，具体来说，下标为页号p存储的是对应的帧号f，而物理地址偏移与逻辑地址偏移相等。

> 页映射到帧；
> 页是连续的虚拟内存；
> 帧是非连续的物理地址；
> 不是所有的页都有对应的帧。

### 页表

 - 页表访问速度问题

使用TLB(Translation Look-aside Buffer，具备快速访问性能)缓存近期访问页表项。

 - 页表存储空间问题

使用多级页表，减小不必要的页表项存储；但是页表级数变多时，映射访问就变得繁锁。如下是一个二级级表的示例：

```text
逻辑地址宽度：P1+P2+S 位
|----------------------------------------------|
|一级分页=P1位 |二级分页=P2位 | 页内偏移位=S位 |
|----------------------------------------------|

有两个页号，对应也有两个页表（数组）,通过index访问：
一级页表Table[2 ^ p1] = 二级页表的index
二级页表Table[index ] = 物理地址帧号f
```

建立反向页表，让页表与物理地址空间对应。可以这样理解，逻辑地址对应的物理地址存在，才将映射放入页表中，所以，这是一个大（逻辑）地址空间，到 小（物理）地址空间的映射，可以使用Hash表来建立这种映射关系，不过要注意Hash的碰撞问题。

```text
Hash(PID, p) = f
进行Hash计算时，可以加入程序PID等参数，缓解碰撞问题。
```

## 虚拟内存

理想的存储器：更大、更快、更便宜的非易失性存储器

### 覆盖技术

为了在较小的内存中运行较大的程序，将程序划分成若干功能相互独立的功能模块：

 - 必要部分：放于内存
 - 可选部分：平在放于外存，需要时才装入内存

不存在调用关系的模块不必同时装入内存，从而可以相互覆盖。
但是，为了确定覆盖关系，会增加编程的复杂度，而从外存装载数据到内存，会增加时间开销。

```
                                   -------------
       A(20K)             A    -> |常驻区(20K)  |
      /      \                    |-------------|
 B(50K)     C(30K)        B,C  -> |覆盖区0 (50K)|
   |        /   \                 |-------------|
 D(30K) E(20K)  F(40K)    D,E,F-> |覆盖区1 (40K)|
                                 -------------

另一种覆盖方法：
 A     -> 常驻区 (20K)
 B,E,F -> 覆盖区0 (50K)
 C,D   -> 覆盖区1 (30K)
```

### 交换技术

将暂时不运行的程序（进程地址空间）放入外存，从而获取内存空间。交换技术发生在程序之间，而覆盖技术发生在程序的模块之间。

```text
|-----------|               |-----------|
| Os Memory |               |           |
|-----------|               |           |
|           |               |-----------|
|           | --Swap out--> | Process1  |
|           |               |-----------|
|           |               |           |
|           |               |-----------|
|           | <--Swap in--- | Process2  |
|-----------|               |-----------|
  Memory                Disk
```

交换时需要考虑：
 - Swap时机：当内存空间不够时进行Swap；
 - Swap大小：Swap区应该足够大，能放入所有用户程序；
 - Process重定位：采用动态地址映射。

### 虚存技术

基于页式或段式内存管理的基础上实现：

 - 装载：只加载当前需要的部分页面或段到内存；
 - 执行：如果需要指令或数据尚未在内存，则由处理器通知操作系统加载相应的页面或段；同时，将不需要的页面和段放入外存中。

虚拟内存的特征：

 - 大的用户空间：物理内存和外存相结合，可以提供更大的虚拟内存空间；
 - 部分交换：与交换技术相比，是部分虚拟地址空间的调入和调出；
 - 不连续性：物理内存分配不连续，虚拟地址空间使用的不连续。

### 页面置换

发生缺页中断时，且内存页面已满时，选择某个物理内存页被置换。

几种局部页面置换算法：

 - 最优页面置换算法
发生缺页中断时，置换等待时间最长的页面。实际中无法实现，因为操作系统不知道未来哪个页面的等行时间最长。不过可以作为其它页面置换算法的性能评价依据。

 - 先进先出算法（FIFO）
置换在内存中驻留时间最长的页面。性能较差，很少单独使用。使用FIFO算法，有时物理页帧分配增加，缺页机率增大，称为Belay现象。

 - 最近最久未使用算法（Least Recently Used, LRU）
置换最久未使用的那个页面。LRU算法需要记录各个页面使用时间的先后顺序。

 - 时钟页面置换算法（Clock）
与LRU近似，是对FIFO的改进。根据页面访问标志位，置换相对较久未使用的页面（或者等待时间最久且未使用的页面）。

 - 二次机会法
有修改的页面保留的机率更大，而没有修改的页修被置换的机率更大。根据页面访问标志位和读写标志位，来确定置换的页面。

```text
Used, Write -> Used, Write
  0 , 0          (Replace)
  0 , 1          0 , 0 (Keep)
  1 , 0          0 , 0 (Keep)
  1 , 1          0 , 1 (Keep)

Used: 访问标志位，最近是否被访问
Write: 读写标志位，是否有修改
```

 - 最不常用算法（Least Frequently Used, LFU)
置换访问次数最少的页面。

---
# OS进程

## 进程概念

进程是一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程，而程序是一个静态的二进制代码。

 - 进程与程序的联系：

```text
 1 程序是产生进程的基础
 2 程序的每次运行构成不同的进程
 3 进程是程序功能的体现
 4 一个程序可以对应多个进程（多次执行）
 5 一个进程可以包括外个程序（调用关系）
```

 - 进程与程序的区别：

```text
 1 进程是动态的，程序是静态的
 2 进程是暂时的，程序是永久的
 3 进程与程序的组成不同：进程的组成包括程序、数据和进程控制块（进程状态信息）
```

 - 进程的特点：

```text
 1 动态性：可以动态创建、结束进程
 2 并发性：进程可以被独立调度并占用处理机运行
           【并发：一个短的时间段内，有多个进程运行，一个CPU也可以执行并发
             并行：一个时刻有多个进程运行，只有多个CPU（多核CPU）才能并行】
 3 独立性：不同进程的工作不相互影响
 4 制约性：因访问共享数据/资源或进程同步而产生制约
```

## 进程管理

### 进程序控制块

进程控制块（Process Control Block, PCB）：操作系统管理控制进程运行所用的信息集合，是进程存在的唯一标志。

 - PCB的三大类信息：

```text
 1 进程标识信息：如进程标识、父进程标识、用户标识
 2 处理机状态信息保存区：保存进程运行的现场信息
 3 进程控制信息：用于进程的管理与控制
```

 - PCB的组织方式：

```text
 1 链表：同一状态的进程其PCB组成一个链表，多个状态对应多个不同链表。
         链表能很好的实现进程的动态创建与删除。
 2 索引表：同一状态的进程归于一个index表（由index指向PCB），多个状态对应不同的index表。
           进程数相对固定时，用数组能较好的管理进程。
```

### 进程生命期

 - 进程生命期可能的状态：

```text
 1 进程创建
 2 进程运行
 3 进程等待（阻塞）：进程只能自身阻塞自身
 4 进程唤醒：进程只能被别的进程或操作系统唤醒
 5 进程结束
```

进程的三个基本状态：运行状态（Running）、就绪状态（Ready）、阻塞状态（Blocked）
进程的其它状态：创建状态（New）、结束状态（Exit）

```text
                          6
            ┌--> Running ---> Exit
            |      |  |
            |2    3|  |5
      2     |      |  |
 New ---> Ready <--┘  └--> Blocked
            ^                 |
            └-----------------┘
                 4
 1. 进入就绪队列
 2. 被调度
 3. 时间片执行完毕
 4. 束件发生
 5. 等待事件
 6. 结束
```

### 进程挂起

挂起（Suspend）是指把一个进程从内存转到外存。
解挂/激活（Activate）是指把一个进程从外存转到内存。
进程在挂起时，意味着没有占用内存空间。处于挂起状态的进程映像在磁盘上。

 - 阻塞挂起状态（Blocked-suspend）：进程在外存等待某事件的出现
 - 就绪挂起状态（Ready-suspend）：进程在外存，但只要进入内存，即可运行


## 线程

### 线程管理

线程（Thread）是进程中的一条执行流程。

 - 线程的优点：

```text
 1 一个进程可以同时存在多个线程
 2 各个线程之间可以并发执行
 3 各个线程之间可以共享地址空间和文件等资源
```

 - 线程的缺点： 一个线程崩溃，会导致所属进程的所有线程崩溃。

 - 线程与进程比较

```text
 1 进程是资源分配单位，线程是CPU调度单位
 2 进程拥有一个完整的资源平台，而线程只独享必不可少的资源（如寄存器和栈等）
 3 线程同样具有就绪、阻塞和执行三种基本状态，同样具有状态之间的转换关系
 4 线程能减少并发执行的时间和空间开销
```

### 线程实现

 - 用户线程（User Thread）：在用户空间实现的线程机制，不需要依赖于操作系统的内核，由一组用户级的线程库函数完成线程管理。

用户线程缺点：

```text
 1 如果一个线程发起系统调用而阻塞，则整个进程在等待
 2 当一个线程开始运行后，除非它主动交出CPU的使用权，则它所在进程的其它线程将无法运行
 3 因为时间片是分配给进程的，所在在多线程执行时，每个线程得到的时间片较少，执行相对较慢
```

 - 内核线程（Kernel Thread）：指在操作系统的内核中实现的一种线程机制，由操作系统的内核来完成线程的创建、终止和管理。

 - 轻量级进程（LightWeight Process）：是内核支持的用户线程。一个进程可有一个或多个轻量级进程，每个轻量级进程由一个单独的内核线程支持。


## 进程调度
